

# FLOW 
## Native token of the FLOW protocol 
The FLOW native token complies to the fungible token standard https://github.com/onflow/flow-ft
## Receiving & Earning FLOW

### Token Delivery
Process for purchasers/holders of FLOW 

**Step 1)** 

Choose a custody provider:

- Coinlist
- Finoa
- Kraken
- Ledger, or
- Create your own Flow account by going to [Flow Port](Coming soon) and selecting "Create Account" under the transactions option. This will submit a transaction to the Flow Faucet which will sign as the payer to create your account.

**Step 2)**

Your chosen custody service will provide you with an option to create a `Flow Address`. The exact steps to complete this may vary but they will require a thorough KYC process - you are done this step when you receive your Flow Address. 

It should look like something like:

`0x3fes82da`

**Step 3)** 

Provide the Flow team your Flow Address and the tokens will be deposited into your account shortly.

You will be able to **check your FLOW balance** anytime on [Flow Port](Insert link to Flow Port). 

### Earning FLOW
There are a number of programs available to earn FLOW tokens. 
* Alpha Program
* Token Lease Staking Program
* Open World Builders



### What can I do with my FLOW?
* Use
* Stake
* Delegate
* Hold
* Vote 
* Send & Share 
* Create, develop, and grow your dapp

### How do I check my FLOW balance?
Visit [Flow Port](Insert link to Flow Port) and sign-in to your Flow Account. Your wallet or custody provider will likely also display your FLOW balance to you.

## Spending Flow 
### How do I use FLOW?
//Fees? Wallets?

## Staking FLOW 

https://github.com/dapperlabs/flow-internal/issues/1147
You can commit tokens to stake with the `send_staking_tokens.cdc` transaction. These tokens are held in escrow in the `StakingHelper` resource. You can submit an official staking request by using the `create_staking_request.cdc` transaction which registers the node operator in the Flow ID Table contract and commits your tokens to be staked in the next epoch.
Alternatively, you may choose to submit an `abort_stake.cdc` transaction which will remove the tokens from escrow and return them to your account, if called prior to the beginning of the epoch. 

If the `create_staking_request.cdc` transaction has been submitted, you can do a few things:
1) Add additional tokens via `stake_new_tokens.cdc` transaction 
2) Remove your stake via `request_unstaking.cdc` transaction, or
3) Withdraw rewards/unstaked tokens via `withdraw_tokens.cdc` transaction (if you've participated in an earlier epoch) 

### Unbonding / Withdrawing Stake
- The process for unbonding stake (removing it from the staked node) requires either party to initiate an unbonding request; which is a function call to the staking helper.
- When the request is approved by the core staking contract, the funds will be locked for one epoch and then transferred into the deposit account as set in the initial staking transaction.
//Insert sequence diagram https://www.notion.so/dapperlabs/Token-Staking-Process-6877e85a057e4eab8beae7f5187f3ffb#6cdcd35f8084439d93da479f1dc0831d
//Insert Unbonding transaction example
https://github.com/dapperlabs/flow-internal/issues/1131


## Delegating FLOW 
A node operator who wants to allow delegation to their node will create a public capability for delegators using the `publish_delegation.cdc` transaction. This capability will only be valid for nodes which have already submitted a staking request and which fulfill the minimum staking requirements for that node type. 
Token holders who wish to delegate to their node submit a `delegate_tokens.cdc` transaction providing the account addreses of the node they want to delegagte to. This transaction creates a capability that the delegator stores in their account which gives them access to: 
1) Staking additional tokens
2) Withdrawig rewards 
3) Requesting to unstake

If a node operator has delegators, they cannot withdraw their own tokens such that their own staked tokens would fall below the minimum requirement for that node type. This is enforced at the protocol level. 

The delegation logic keeps track of the amount of tokens each delegator has delegated for the node operator. When rewards are paid out, the rewards are automatically divided based on the proportion held by that token holder wrt to the total tokens staked. 

// insert min requirements 
//link to delegation docs? https://docs.onflow.org/docs/delegation

### Withdrawing Rewards 

## Holding FLOW
## Voting with FLOW
## Sending & Sharing FLOW
## Creating with FLOW
### Getting Started 
How to get FLOW to create accounts and deploy contracts
https://github.com/dapperlabs/flow-internal/issues/1133
#### On Testnet 
#### On Mainnet
**Fees**
Fees for account creation, and transaction submission will exist in v0.x.x of the testnet.
//update version number and fees applied
There are 2 fees that you will see applied to your transactions
* Account Creation - currently fixed at 0.1 FLOW
* Transaction Fee - currently fixed at 0.0001 FLOW

### Transaction Fees
Transaction fees are applied only once per transaction, at time of execution. Transactions without a valid payer signature will fail and not be included in a block, prior to when the fee would be charged. If there is no one to charge, the transaction never goes through.
However, if a transaction fails for some other reason once it is being executed, you will still be charged the fixed fee. The fee covers the cost of the network looking at the transaction and thus must be paid even if no change to your account is made.
### Storage/Account Fees
Account Creation fee is applied only when create account is called. This fee covers the cost of storing up to 1KB of data in perpetuity.
This fee is applied only once and can be "topped up" to add additional storage to an account.
### When will I need FLOW to start building?
### How do I get FLOW to my users?
### How do I create accounts on my user's behalf?
### How do I transfer FLOW to my users?
### How can I reward users with FLOW?
### Flow Arcade Token 




# Supporting FLOW 
## Deposits
### Transfer Tokens (FLOW)
`transaction(amount: UFix64, to: Address) {
let vault: @FungibleToken.Vault
prepare(signer: AuthAccount) {
self.vault <- signer
.borrow<&{FungibleToken.Provider}>(from: /storage/flowTokenVault)!
.withdraw(amount: amount)
}
execute {
getAccount(to)
.getCapability(/public/flowTokenReceiver)!
.borrow<&{FungibleToken.Receiver}>()!
.deposit(from: <-self.vault)
}
}`
*First Parameter*
`{
"type": "UFix64",
"value": "<integer>.<fractional>"
}`
*Second Parameter*
`{
"type": "Address",
"value": "0x0" // as hex-encoded string with 0x prefix
}`

## Staking 

https://github.com/dapperlabs/flow-internal/issues/1147

As a node operator, you first need to generate your staking key, networking address, node ID, and networking key via 
// link out to consolidated guide
// confirm where node ID is generated

You then need to determine the role of node you'll be running
// link out to application 

Submit a staking request using a `create_staking_request.cdc` transaction. 
This will register your node in the Flow node identity table and commit your tokens to stake during the next epoch. 
This also stores a special node operator object in your account that is used for staking, unstaking, and withdrawing rewards.

Once the new epoch starts, the tokens you have committed will be marked as staked and held in the protocol state. 
At anytime you can submit a `request_unstake.cdc` transaction which will move your tokens to the unbonding pool at the end of the current epoch. They will sit in this pool for one (1) additional epoch, at which point you will be able to withdraw your tokens via `withdraw_tokens.cdc` transaction. 

**Withdrawing Rewards**
Rewards are deposited into your pool of unlocked tokens which you can withdraw at anytime using the `withdraw_tokens.cdc` transaction. 
Rewards are paid out at the end of each epoch, at which point you will be able to submit this transaction. 
You can opt to restake your rewards by submitting the `stake_unlocked_tokens.cdc` transaction. 

#### Staking Helper
If you do not hold tokens yourself, but are relying on someone else to run a node on your behalf, you can submit a staking_request without tokens - this will produce the needed node operator object mentioned above. 
The node operator running your node will need to create a `StakingHelper` resource object and store it in a third party account using the `create_staking_helper.cdc` transaction. 
This transaction needs to be signed by both the node operator and the token holder because it will store a capability in each account to access the third party `StakingHelper` resource.
This resource can also define the reward split between the node operator and token holder - this is done via an `init` argument which is the % of rewards the node operator receives. 
This `StakingHelper` allows you to securely transfer stake to the protocol for those who are using a separate node operation service, without requiring the node operator to take custody of those funds at any time. 

The token holder will need to submit the `send_staking_tokens.cdc` transaction from wherever their tokens are held, before you can take any action. 
//flag support for custody 
Once the token holder has escrowed their staking tokens and you have generated the required node info (staking key, networking address, node ID, and networking key), you or the token holder can submit the `create_staking_request.cdc` transaction which registers the node operator in the Flow ID Table contract and commits the token holders tokens to be staked in the next epoch.

If the `create_staking_request.cdc` transaction has been submitted, you can do a couple things:
1) Remove the token holders stake via `request_unstaking.cdc` transaction (configuring this to require signatures from either or both parties is an available option)
2) Withdraw rewards/unstaked tokens via `withdraw_tokens.cdc` transaction, which will deposit them into the corresponding accounts (this will automatically distribute the rewards to both the staker and node operator, as defined at creation of the StakingHelper resourcee). 

### Unbonding / Withdrawing Stake
- The process for unbonding stake (removing it from the staked node) requires either party to initiate an unbonding request; which is a function call to the staking helper.
- When the request is approved by the core staking contract, the funds will be locked for one epoch and then transferred into the deposit account as set in the initial staking transaction.
//Insert sequence diagram https://www.notion.so/dapperlabs/Token-Staking-Process-6877e85a057e4eab8beae7f5187f3ffb#6cdcd35f8084439d93da479f1dc0831d
//Insert Unbonding transaction example
https://github.com/dapperlabs/flow-internal/issues/1131

## Delegating Stake
A node operator who wants to allow delegation to their node will create a public capability for delegators using the `publish_delegation.cdc` transaction. This capability will only be valid for nodes which have already submitted a staking request and which fulfill the minimum staking requirements for that node type. 
Token holders who wish to delegate to their node submit a `delegate_tokens.cdc` transaction providing the account addreses of the node they want to delegagte to. This transaction creates a capability that the delegator stores in their account which gives them access to: 
1) Staking additional tokens
2) Withdrawig rewards 
3) Requesting to unstake

If a node operator has delegators, they cannot withdraw their own tokens such that their own staked tokens would fall below the minimum requirement for that node type. This is enforced at the protocol level. 

The delegation logic keeps track of the amount of tokens each delegator has delegated for the node operator. When rewards are paid out, the rewards are automatically divided based on the proportion held by that token holder wrt to the total tokens staked. 

// insert min requirements 
//link to delegation docs? https://docs.onflow.org/docs/delegation

## Events
A transaction is identified by its hash which exists as soon as the transaction is signed and submitted.
A user can check the status of a transaction at any time via the Flow block explorer https://flow.bigdipper.live/

For a dapp to provide transaction status natively you would:

Use the a flow-sdk to fetch tx results via:
// insert link

Once the transaction is sealed an event is emitted so the user agent can read the transaction events and update the user.

## FLOWs for Development
https://github.com/dapperlabs/flow-internal/issues/1133
Fees
Fees for account creation, and transaction submission will exist in v0.x.x of the testnet.
//update version number and fees applied
There are 2 fees that you will see applied to your transactions
* Account Creation - currently fixed at 0.1 FLOW
* Transaction Fee - currently fixed at 0.0001 FLOW

### Transaction Fees
Transaction fees are applied only once per transaction, at time of execution. Transactions without a valid payer signature will fail and not be included in a block, prior to when the fee would be charged. If there is no one to charge, the transaction never goes through.
However, if a transaction fails for some other reason once it is being executed, you will still be charged the fixed fee. The fee covers the cost of the network looking at the transaction and thus must be paid even if no change to your account is made.
### Storage/Account Fees
Account Creation fee is applied only when create account is called. This fee covers the cost of storing up to 1KB of data in perpetuity.
This fee is applied only once and can be "topped up" to add additional storage to an account.
Transactions are submitted using a flow SDK via the Access API
Results can be queried by transaction hash through the Access API
// insert link
The Devnet Faucet is a tool for Flow developers to create accounts and fund their accounts with $FLOW tokens on the Flow Development Network.

### Deploying Contracts on Mainnet
Deploying a contract on mainnet will require that you submit your contract for review by a member of the core Cadence team to ensure safety for users.
//Ref Issue to create/link form https://github.com/dapperlabs/flow-internal/issues/1098

## Account Creation
Go to your Flow Dock and select "Create Account" under the transactions option. This will submit a transaction to the Flow Faucet which will sign as the payer to create your account.
//insert link to dock.onflow.org
Funding User accounts
Q: How do I get my first accounts funded?
Q: How do I access free accounts for my users?

## Submitting Transactions to Flow and Result Reporting
On Flow, a transaction is identified by its hash - the hash that exists as soon as that transaction is signed and submitted to an Access or Collection node.
A user can check the status of a transaction at any time via the block explorer.
// link to block explorer
To expose these results natively in your app, you can use the flow-sdk to fetch transaction results via
https://github.com/onflow/flow-go-sdk#querying-events
Once the transaction is sealed, an event is emitted and you will be able to read `tx events`
Transactions are submitted using a Flow SDK via the Access API.
Results of transactions can be queried by transaction hash through the Access API.


### Checking Balance
Use the flow-sdk to fetch transaction results https://github.com/onflow/flow-go-sdk#querying-events
* [Fetch account state by address from a Flow Access API](https://github.com/onflow/flow-go-sdk#querying-accounts)
Once the transaction is sealed, an event is emitted and you will be able to read `tx events`* [Poll for TokenDeposited events using the Flow Acess API](https://github.com/onflow/flow-go-sdk#querying-events)
* [Poll for TokenDeposited events using the Flow Acess API](https://github.com/onflow/flow-go-sdk#querying-events)

### Withdrawing Tokens (including rewards
)
### On Testnet
### On Mainnet

### Transaction Templates 
## Transaction Templates to get you Started
### Transfer Tokens (FLOW)
`transaction(amount: UFix64, to: Address) {
let vault: @FungibleToken.Vault
prepare(signer: AuthAccount) {
self.vault <- signer
.borrow<&{FungibleToken.Provider}>(from: /storage/flowTokenVault)!
.withdraw(amount: amount)
}
execute {
getAccount(to)
.getCapability(/public/flowTokenReceiver)!
.borrow<&{FungibleToken.Receiver}>()!
.deposit(from: <-self.vault)
}
}`
*First Parameter*
`{
"type": "UFix64",
"value": "<integer>.<fractional>"
}`
*Second Parameter*
`{
"type": "Address",
"value": "0x0" // as hex-encoded string with 0x prefix
}`
### Create Account
`transaction(publicKeys: [[UInt8]]) {
prepare(signer: AuthAccount) {
let acct = AuthAccount(payer: signer)
for key in publicKeys {
acct.addPublicKey(key)
}
}
}`
*First Parameter*
`{
"type": "Array",
"value": [
  {
    "type": "Array",
    "value": [
      {"type":"UInt8", value: 123},
      ...
     ]
  },
  ...
 ]
}`

### Add New Key
`transaction(publicKey: [UInt8]) {
prepare(signer: AuthAccount) {
let acct = AuthAccount(payer: signer)
acct.addPublicKey(key)
}
}`
*First Parameter*
`{
    "type": "Array",
    "value": [
      {"type":"UInt8", value: 123},
      ...
     ]
  }`



ALTERNATE LAYOUT BELOW
-------------------
<where do events go in this layout? 

A transaction is identified by its hash which exists as soon as the transaction is signed and submitted.
A user can check the status of a transaction at any time via the Flow block explorer https://flow.bigdipper.live/

For a dapp to provide transaction status natively you would:

Use the a flow-sdk to fetch tx results via:
// insert link

Once the transaction is sealed an event is emitted so the user agent can read the transaction events and update the user.
## As a wallet provider...

### for using, staking, delegating FLOW
You can commit tokens to stake with the `send_staking_tokens.cdc` transaction. These tokens are held in escrow in the `StakingHelper` resource. You can submit an official staking request by using the `create_staking_request.cdc` transaction which registers the node operator in the Flow ID Table contract and commits your tokens to be staked in the next epoch.
Alternatively, you may choose to submit an `abort_stake.cdc` transaction which will remove the tokens from escrow and return them to your account, if called prior to the beginning of the epoch. 

If the `create_staking_request.cdc` transaction has been submitted, you can do a few things:
1) Add additional tokens via `stake_new_tokens.cdc` transaction 
2) Remove your stake via `request_unstaking.cdc` transaction, or
3) Withdraw rewards/unstaked tokens via `withdraw_tokens.cdc` transaction (if you've participated in an earlier epoch) 

### Unbonding / Withdrawing Stake
- The process for unbonding stake (removing it from the staked node) requires either party to initiate an unbonding request; which is a function call to the staking helper.
- When the request is approved by the core staking contract, the funds will be locked for one epoch and then transferred into the deposit account as set in the initial staking transaction.
//Insert sequence diagram https://www.notion.so/dapperlabs/Token-Staking-Process-6877e85a057e4eab8beae7f5187f3ffb#6cdcd35f8084439d93da479f1dc0831d
//Insert Unbonding transaction example
https://github.com/dapperlabs/flow-internal/issues/1131


## Delegating FLOW 
A node operator who wants to allow delegation to their node will create a public capability for delegators using the `publish_delegation.cdc` transaction. This capability will only be valid for nodes which have already submitted a staking request and which fulfill the minimum staking requirements for that node type. 
Token holders who wish to delegate to their node submit a `delegate_tokens.cdc` transaction providing the account addreses of the node they want to delegagte to. This transaction creates a capability that the delegator stores in their account which gives them access to: 
1) Staking additional tokens
2) Withdrawig rewards 
3) Requesting to unstake

If a node operator has delegators, they cannot withdraw their own tokens such that their own staked tokens would fall below the minimum requirement for that node type. This is enforced at the protocol level. 

The delegation logic keeps track of the amount of tokens each delegator has delegated for the node operator. When rewards are paid out, the rewards are automatically divided based on the proportion held by that token holder wrt to the total tokens staked. 

// insert min requirements 
//link to delegation docs? https://docs.onflow.org/docs/delegation

https://github.com/dapperlabs/flow-internal/issues/1147

#### Withdrawing Rewards 
### for voting, receiving, playing, and participating with FLOW
It is possible to use the Flow blockchain without holding any FLOW tokens yourself. Free to play games, trials, community polls, and other community activities can all take place with only an account (which may be created on a person's behalf) and a small fixed fee which may paid by a user agent. The protocol requires some FLOW tokens to process these transactions but (and this is the cool part!) a product can support users who do not themselves hold FLOW while still providing that user with all the underlying security guarantees the Flow protocol provides. 
//insert flow faucet docs
## As a custody provider...
### Supporting Deposits of FLOW

**Step 1)** 
Perform necessary KYC and provide user with their Flow address.

It should look like something like:

`0x3fes82da`
[Creating Accounts on Flow](https://github.com/onflow/flow-go-sdk#creating-an-account)

**Step 2)**

Subscribe to events related to your user's accounts to notify and update account balance in UI 
[Querying Accounts](https://github.com/onflow/flow-go-sdk#querying-accounts)

//insert protocol for emitting event when tokens deposited into account

//insert generalised websequence digram from this doc https://docs.google.com/document/d/1b1fVgHBlGYMu0WvIz5fwDMc153UGzXz0Pp2lr1atRrE/edit#heading=h.vyfahjj5ho25 **@psiemens**

Supporting delivery of tokens 
### Transfer Tokens (FLOW)
`transaction(amount: UFix64, to: Address) {
let vault: @FungibleToken.Vault
prepare(signer: AuthAccount) {
self.vault <- signer
.borrow<&{FungibleToken.Provider}>(from: /storage/flowTokenVault)!
.withdraw(amount: amount)
}
execute {
getAccount(to)
.getCapability(/public/flowTokenReceiver)!
.borrow<&{FungibleToken.Receiver}>()!
.deposit(from: <-self.vault)
}
}`
*First Parameter*
`{
"type": "UFix64",
"value": "<integer>.<fractional>"
}`
*Second Parameter*
`{
"type": "Address",
"value": "0x0" // as hex-encoded string with 0x prefix
}`


### Holding and/or Using FLOW
**Creating Accounts**
**Submitting Transactions to Flow**
### Staking and/or Delegating FLOW 
You can commit tokens to stake with the `send_staking_tokens.cdc` transaction. These tokens are held in escrow in the `StakingHelper` resource. You can submit an official staking request by using the `create_staking_request.cdc` transaction which registers the node operator in the Flow ID Table contract and commits your tokens to be staked in the next epoch.
Alternatively, you may choose to submit an `abort_stake.cdc` transaction which will remove the tokens from escrow and return them to your account, if called prior to the beginning of the epoch. 

If the `create_staking_request.cdc` transaction has been submitted, you can do a few things:
1) Add additional tokens via `stake_new_tokens.cdc` transaction 
2) Remove your stake via `request_unstaking.cdc` transaction, or
3) Withdraw rewards/unstaked tokens via `withdraw_tokens.cdc` transaction (if you've participated in an earlier epoch) 

### Unbonding / Withdrawing Stake
- The process for unbonding stake (removing it from the staked node) requires either party to initiate an unbonding request; which is a function call to the staking helper.
- When the request is approved by the core staking contract, the funds will be locked for one epoch and then transferred into the deposit account as set in the initial staking transaction.
//Insert sequence diagram https://www.notion.so/dapperlabs/Token-Staking-Process-6877e85a057e4eab8beae7f5187f3ffb#6cdcd35f8084439d93da479f1dc0831d
//Insert Unbonding transaction example
https://github.com/dapperlabs/flow-internal/issues/1131


## Delegating FLOW 
A node operator who wants to allow delegation to their node will create a public capability for delegators using the `publish_delegation.cdc` transaction. This capability will only be valid for nodes which have already submitted a staking request and which fulfill the minimum staking requirements for that node type. 
Token holders who wish to delegate to their node submit a `delegate_tokens.cdc` transaction providing the account addreses of the node they want to delegagte to. This transaction creates a capability that the delegator stores in their account which gives them access to: 
1) Staking additional tokens
2) Withdrawig rewards 
3) Requesting to unstake

If a node operator has delegators, they cannot withdraw their own tokens such that their own staked tokens would fall below the minimum requirement for that node type. This is enforced at the protocol level. 

The delegation logic keeps track of the amount of tokens each delegator has delegated for the node operator. When rewards are paid out, the rewards are automatically divided based on the proportion held by that token holder wrt to the total tokens staked. 

// insert min requirements 
//link to delegation docs? https://docs.onflow.org/docs/delegation

### Withdrawing Rewards 

## As a node operator...

As a node operator, you first need to generate your staking key, networking address, node ID, and networking key via 
// link out to consolidated guide
// confirm where node ID is generated

You then need to determine the role of node you'll be running
// link out to application 

Submit a staking request using a `create_staking_request.cdc` transaction. 
This will register your node in the Flow node identity table and commit your tokens to stake during the next epoch. 
This also stores a special node operator object in your account that is used for staking, unstaking, and withdrawing rewards.

Once the new epoch starts, the tokens you have committed will be marked as staked and held in the protocol state. 
At anytime you can submit a `request_unstake.cdc` transaction which will move your tokens to the unbonding pool at the end of the current epoch. They will sit in this pool for one (1) additional epoch, at which point you will be able to withdraw your tokens via `withdraw_tokens.cdc` transaction. 

**Withdrawing Rewards**
Rewards are deposited into your pool of unlocked tokens which you can withdraw at anytime using the `withdraw_tokens.cdc` transaction. 
Rewards are paid out at the end of each epoch, at which point you will be able to submit this transaction. 
You can opt to restake your rewards by submitting the `stake_unlocked_tokens.cdc` transaction. 

#### Staking Helper
If you do not hold tokens yourself, but are relying on someone else to run a node on your behalf, you can submit a staking_request without tokens - this will produce the needed node operator object mentioned above. 
The node operator running your node will need to create a `StakingHelper` resource object and store it in a third party account using the `create_staking_helper.cdc` transaction. 
This transaction needs to be signed by both the node operator and the token holder because it will store a capability in each account to access the third party `StakingHelper` resource.
This resource can also define the reward split between the node operator and token holder - this is done via an `init` argument which is the % of rewards the node operator receives. 
This `StakingHelper` allows you to securely transfer stake to the protocol for those who are using a separate node operation service, without requiring the node operator to take custody of those funds at any time. 

The token holder will need to submit the `send_staking_tokens.cdc` transaction from wherever their tokens are held, before you can take any action. 
//flag support for custody 
Once the token holder has escrowed their staking tokens and you have generated the required node info (staking key, networking address, node ID, and networking key), you or the token holder can submit the `create_staking_request.cdc` transaction which registers the node operator in the Flow ID Table contract and commits the token holders tokens to be staked in the next epoch.

If the `create_staking_request.cdc` transaction has been submitted, you can do a couple things:
1) Remove the token holders stake via `request_unstaking.cdc` transaction (configuring this to require signatures from either or both parties is an available option)
2) Withdraw rewards/unstaked tokens via `withdraw_tokens.cdc` transaction, which will deposit them into the corresponding accounts (this will automatically distribute the rewards to both the staker and node operator, as defined at creation of the StakingHelper resourcee). 

### Unbonding / Withdrawing Stake
- The process for unbonding stake (removing it from the staked node) requires either party to initiate an unbonding request; which is a function call to the staking helper.
- When the request is approved by the core staking contract, the funds will be locked for one epoch and then transferred into the deposit account as set in the initial staking transaction.
//Insert sequence diagram https://www.notion.so/dapperlabs/Token-Staking-Process-6877e85a057e4eab8beae7f5187f3ffb#6cdcd35f8084439d93da479f1dc0831d
//Insert Unbonding transaction example
https://github.com/dapperlabs/flow-internal/issues/1131

## Delegating Stake
A node operator who wants to allow delegation to their node will create a public capability for delegators using the `publish_delegation.cdc` transaction. This capability will only be valid for nodes which have already submitted a staking request and which fulfill the minimum staking requirements for that node type. 
Token holders who wish to delegate to their node submit a `delegate_tokens.cdc` transaction providing the account addreses of the node they want to delegagte to. This transaction creates a capability that the delegator stores in their account which gives them access to: 
1) Staking additional tokens
2) Withdrawig rewards 
3) Requesting to unstake

If a node operator has delegators, they cannot withdraw their own tokens such that their own staked tokens would fall below the minimum requirement for that node type. This is enforced at the protocol level. 

The delegation logic keeps track of the amount of tokens each delegator has delegated for the node operator. When rewards are paid out, the rewards are automatically divided based on the proportion held by that token holder wrt to the total tokens staked. 

// insert min requirements 
//link to delegation docs? https://docs.onflow.org/docs/delegation
https://github.com/dapperlabs/flow-internal/issues/1147


### Withdrawing Rewards 
# Key Concepts
## Fees 
Fees for account creation, and transaction submission will exist in v0.x.x of the testnet.
//update version number and fees applied
There are 2 fees that you will see applied to your transactions
* Account Creation - currently fixed at 0.1 FLOW
* Transaction Fee - currently fixed at 0.0001 FLOW

### Transaction Fees
Transaction fees are applied only once per transaction, at time of execution. Transactions without a valid payer signature will fail and not be included in a block, prior to when the fee would be charged. If there is no one to charge, the transaction never goes through.
However, if a transaction fails for some other reason once it is being executed, you will still be charged the fixed fee. The fee covers the cost of the network looking at the transaction and thus must be paid even if no change to your account is made.
### Storage/Account Fees
Account Creation fee is applied only when create account is called. This fee covers the cost of storing up to 1KB of data in perpetuity.
This fee is applied only once and can be "topped up" to add additional storage to an account.

### Paying Fees
### When are fees applied?

## Rewards
### Withdrawing Rewards
